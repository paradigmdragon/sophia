---
title: SonE Protocol v2.0
description: Structured Automation Language for 손잡고 Platform
version: 2.0
last_update: 2025-11-26
status: 언어 정의 + 자동화 구조 + 실행기 연동 완성본
---

# SonE Protocol v2.0 — Structured Automation Language

**Last Update:** 2025-11-26

**Status:** 언어 정의 + 자동화 구조 + 실행기 연동 완성본

**Purpose:** 손잡고 플랫폼 전용 협업·보상 자동화 DSL

⸻

## 0. 개요

SonE는 손잡고 플랫폼의 자동화 구조를 표준 문장 형식으로 표현하기 위해 설계된 DSL(Domain-Specific Language)이다.

자연어로 작성된 의도를 구조화된 코드로 바꾸어 프로젝트·퀘스트·정표·지분·알림·리포트 등의 전 과정을 자동화하는 역할을 수행한다.

### SonE의 설계 목표

SonE는 다음 세 가지 목표를 기반으로 설계되었다.

**① 복잡한 협업 로직을 구조화**

- 규칙, 조건, 반복, 후속 처리 같은 협업 절차를 "한 문장 = 한 의도"로 명확히 표현.

**② 자연어 ↔ 실행 코드 사이의 중간 언어**

- 사용자/운영자/AI/시스템이 모두 이해 가능한 공통 표현식.
- 자연어 → SonE → AST → Executor → 도메인 모듈.

**③ 실행 가능한 자동화 규칙 저장소**

- 프로젝트 템플릿
- 자동 퀘스트 시스템
- SP/PP 후속 처리
- 알림 및 리포트 자동화
- 데이터 정리 및 주기적 스케줄

을 일관된 형태로 기록·관리.

### SonE의 철학적 배경

SonE는 감정에 흔들리지 않는 AI와, 가치와 의미를 지닌 인간의 세계관이 만나는 지점에 놓인 **다리이자 번역기이며, 설계 언어**입니다.

서로 다른 존재가 손을 맞잡고 함께 미래를 설계할 수 있도록, **공존을 가능하게 하는 언어와 구조**를 제공합니다.

SonE의 철학은 플랫폼의 정·리·의 철학과 병렬 구조이며, 언어의 목적은 "자동화를 구조화하는 기술적 DSL"에 집중한다.

### Bicameral Integration (양뇌 통합)

SonE는 소피아의 양뇌 아키텍처 위에서 실행 언어로 기능한다.

- **Left SonE (Local):** 사용자의 의도(Intent)를 실행 가능한 명령으로 변환하고, UI와 직접 상호작용한다.
- **Right SonE (Server):** 실행된 명령의 구조적 정합성을 검증하고, Epidora 패턴과 대조하여 오류 신호(Signal)를 생성한다.

⸻

## 1. SonE 전체 실행 흐름

SonE는 아래와 같은 7단계로 동작한다.

```
1. 자연어 의도
       ↓ (AI 변환)

2. SonE 스크립트 생성
       ↓ (파서)

3. SonE AST 구조화
       ↓

4. Executor 실행
       ↓

5. 도메인 핸들러 호출
       ↓

6. DB/도메인 상태 변경
       ↓

7. Manifest 재정렬 → UI 반영
```

### 단계별 설명

**1) 자연어 입력**

사용자가 원하는 자동화 규칙을 말한다. AI는 이를 SonE 문장 구조로 변환한다.

**2) SonE 스크립트**

명령·조건·대상·액션이 한 문장으로 표현된다.

**3) 파서(Parser) → AST**

토큰 단위로 문장을 분석해 구조화된 AST를 생성한다.

**4) Executor**

AST를 순회하며 어떤 핸들러를 호출할지 결정한다.

**5) 도메인 모듈 호출**

프로젝트, 퀘스트, SP, PP, 알림, Manifest 등 실제 기능 수행.

**6) 상태 변경**

데이터베이스 업데이트.

**7) Manifest 갱신**

모든 변경 사항이 하나의 JSON Snapshot으로 정리된다. UI는 Manifest를 기반으로 실시간 갱신된다.

⸻

## 2. SonE의 주요 사용처 (핵심 6개)

**1) 프로젝트 자동화**

- 생성/종료 시 자동 설정
- 프로젝트 멤버 온보딩
- 상태 기반 흐름

**2) 퀘스트 및 목표 생성**

- 이벤트 기반 퀘스트 자동 생성
- 매일/매주 기반 반복 퀘스트

**3) 정표(SP) 후속 처리**

- 감사 알림
- SP 기록 로그
- 프로젝트 히스토리 반영

**4) 지분(PP) 계산 자동화**

- 특정 이벤트에 따른 PP 계산
- 조건 기반 계산
- 프로젝트 보상 후속 처리

**5) 알림 및 리포트 자동화**

- 개인 요약
- 프로젝트 분석
- 매일/매주 리포트 발송

**6) 주기적 데이터 정리**

- 로그 압축
- 만료 데이터 삭제
- 사용자 프로필 정리

SonE는 이 모든 절차를 한 언어로 통합 표현한다.

⸻

## 3. SonE 문장 구조

SonE 문장은 다음의 고정된 구조로 구성된다.

```
선언부 → 조건부 → 대상 → 액션 → 옵션/시점
```

### 예시:

```
! schedule.daily "09:00"
? quests.pending > 0
@ me
: notify.summary "daily_tasks"
~ silent
```

### 구조 요소 설명

**1) 선언부(!)**

문장의 시작. 트리거·이벤트·스케줄 등의 발생 조건을 담는다.

**2) 조건부(?)**

필터, 비교, 포함 여부 등 조건 판단.

**3) 대상(@)**

이 액션이 적용될 주체(사용자, 프로젝트, 리스트 등).

**4) 액션(:)**

퀘스트 생성, 알림 발송, SP 기록, PP 계산 등 실행 동작.

**5) 옵션(~)**

시점, 부가 설정, 태그, 리플레이 옵션 등.

⸻

## 4. SonE 핵심 기호 요약 (Quick Reference)

| 기호 | 역할                         |
| ---- | ---------------------------- |
| `!`  | 선언(트리거, 이벤트, 스케줄) |
| `?`  | 조건                         |
| `@`  | 대상 지정                    |
| `:`  | 액션 실행                    |
| `~`  | 옵션/시점/부가 설정          |
| `{}` | 블록 구조                    |
| `[]` | 리스트                       |
| `()` | 파라미터                     |
| `$`  | 참조(변수, 경로)             |
| `#`  | 함수 호출                    |
| `+`  | 순차 실행                    |
| `/`  | 조건 분기(else)              |
| `\|` | 병렬 실행                    |
| `//` | 주석                         |

**기호 순서는 유연하게 배치 가능**합니다. 파서는 각 기호의 의미를 식별하여 **위치에 상관없이 정확히 해석**합니다. 단, 문장 안에 기호는 **중복되지 않고 하나씩만 포함**되어야 하며, **해석 충돌이 없도록 구성**해야 합니다.

### 파싱 기준은 "기호 의미 중심"

각 기호는 **자신의 의미만 정확하면 위치는 유연**하게 조합됩니다.

⸻

## 5. 제어 구조 요약

### 조건

```
? a > b
? x in ["A","B","C"]
? user.level >= 2
```

### 블록 구조

```
{
   : action1
   : action2
}
```

### 반복 처리

반복문은 제공하지 않는다. 대상(@)에 리스트를 제공하면 Executor가 자동으로 반복 처리한다.

⸻

## 6. 리소스/경로 구조

SonE는 플랫폼의 모든 도메인 데이터를 경로 기반으로 접근한다.

### 지원되는 도메인 경로

- `projects.*`
- `quests.*`
- `sp.*`
- `pp.*`
- `profile.*`
- `manifest.*`
- `notifications.*`
- `economy.*`
- `activity.*`

### 네임스페이스 접근

- `$user::email` - 객체 속성 접근
- `$config::theme::color` - 체인 접근

⸻

## 7. 도메인 핸들러 목록

Executor는 AST를 순회하며 아래 핸들러들을 호출한다.

- `console` - 콘솔 출력
- `file` - 파일 I/O
- `time/schedule` - 시간/스케줄 관리
- `projects` - 프로젝트 관리
- `quests` - 퀘스트 관리
- `sp` - 정표(SP) 처리
- `pp` - 지분(PP) 처리
- `notifications` - 알림 발송
- `manifest` - Manifest 업데이트
- `automation` - 자동화 규칙
- `economy` - 경제 시스템

각 핸들러는 SonE 액션을 백엔드 모듈의 실제 함수로 맵핑한다.

⸻

## 8. 3비트 매핑 상세 정의

SonE는 모든 명령을 **3비트 단위 명령어와 특수기호 조합**으로 구성한다.

### & 대상 (&, 누가, 무엇을 대상으로?)

&는 **명령의 적용 대상**을 지정합니다. 실행 명령, 상태 변화, 조건 판별 시 **어떤 객체 또는 계층**에 작용할지를 선언하는 기호입니다.

| **코드** | **명칭** | **의미**            | **설명**                        |
| -------- | -------- | ------------------- | ------------------------------- |
| &000     | 데이터   | 원시값, 변수        | 값, 숫자, 문자열, 구조체 등     |
| &001     | 파일     | 파일, 저장 단위     | 파일 객체, 경로, 리소스 핸들 등 |
| &010     | 사용자   | 유저 객체           | 사람, 유저 ID, 에이전트 등      |
| &011     | 시스템   | 하드웨어, 장치      | 서버, 디바이스, 인프라          |
| &100     | 네트워크 | 통신 또는 API       | 패킷, URL, HTTP, Webhook        |
| &101     | 시간     | 지연 또는 시간 단위 | 일정, 타이머, 예약 트리거       |
| &110     | 상태     | 상태 변수 참조      | @진, @감 등 현재 상태 조회      |
| &111     | 규칙     | 조건/로직           | 조건문, 설정 로직, 정책 규칙 등 |

### @ 상태 (@ 어떤 상태일 때)

@는 시스템 또는 객체의 **현재 상태를 3비트로 표현**하는 기호입니다. 실행 흐름을 제어하거나 조건 판별 시 기준으로 사용됩니다.

| **코드** | **의미**    | **영어 매핑** | **예시**                                  |
| -------- | ----------- | ------------- | ----------------------------------------- |
| @000     | 연결됨      | CONNECTED     | `?000&011@000:#로그기록($연결상태)`       |
| @001     | 대기/비활성 | IDLE          |                                           |
| @010     | 실행 중     | RUNNING       | `?000&011@010:#모니터링()`                |
| @011     | 요청 수신   | RECEIVING     |                                           |
| @100     | 오류/예외   | ERROR         | `?111&001@100:110+#로그남기기($에러코드)` |
| @101     | 출력 중     | OUTPUTTING    |                                           |
| @110     | 차단/종료   | BLOCKED       |                                           |
| @111     | 완료됨      | COMPLETED     |                                           |

### ^ 논리연산자 (^, 그리고/또는)

조건의 흐름을 제어하기 위해 ^ 기호와 3비트 조합으로 구성된 논리 연산자를 사용합니다.

| **코드** | **연산자** | **의미**             | **설명**               |
| -------- | ---------- | -------------------- | ---------------------- |
| ^000     | PASS       | 조건 없음            | 기본 실행, 무조건 통과 |
| ^001     | AND        | 모두 참일 때 실행    | 다중 조건 충족         |
| ^010     | OR         | 하나라도 참이면 실행 | 조건 중 일부 충족      |
| ^011     | XOR        | 상반된 조건일 때 참  | 배타 조건 실행         |
| ^100     | NAND       | AND의 부정           | 하나라도 거짓이면 참   |
| ^101     | NOR        | OR의 부정            | 모두 거짓일 때만 참    |
| ^110     | XNOR       | 동일 조건일 때 참    | 모두 참 또는 모두 거짓 |
| ^111     | NOT        | 조건의 부정          | 단일 조건 반전         |

### ? 조건문 (?, 만약 ~ 라면)

?는 **조건 블록의 시작**을 나타냅니다. 뒤따르는 3비트 코드에 따라 **조건의 종류**가 결정되며, : 기호로 조건이 참일 때 실행할 내용을 지정합니다.

| **코드** | **명칭**  | **의미**      | **설명**                                |
| -------- | --------- | ------------- | --------------------------------------- |
| ?000     | IF_EQ     | 값이 같으면   | 비교 대상이 정확히 일치                 |
| ?001     | IF_NE     | 값이 다르면   | 불일치 시 참                            |
| ?010     | IF_GT     | 값이 크면     | Greater Than                            |
| ?011     | IF_LT     | 값이 작으면   | Less Than                               |
| ?100     | IF_EXISTS | 존재할 경우   | 존재 여부 판단 (null 체크 등)           |
| ?101     | IF_EMPTY  | 비어있을 경우 | 배열, 문자열, 객체가 비어있음           |
| ?110     | IF_MATCH  | 문자열 일치   | 정규표현식 또는 부분 포함도 확장 가능   |
| ?111     | IF_FAIL   | 실패 상태이면 | 예외 상태 판별 또는 반환값 에러 검사 등 |

### : 조건 실행 (:, 그러면 ~해라)

:는 ? 조건이 **참일 경우 실행할 명령**을 정의합니다. 단독으로도 사용되며, 복합 조건 또는 흐름 제어에서 활용됩니다.

| **코드** | **명칭** | **의미**         |
| -------- | -------- | ---------------- |
| :000     | EXEC     | 실행 (기본)      |
| :001     | LOG      | 기록, 출력       |
| :010     | HALT     | 정지 또는 중단   |
| :011     | SKIP     | 건너뛰기         |
| :100     | WARN     | 경고 메시지 출력 |
| :101     | RETRY    | 재시도           |
| :110     | THROW    | 예외 발생        |
| :111     | RECOVER  | 복구 시도        |

### ~ 부사어 (~이렇게)

~는 **실행 방식이나 시점**을 제어하는 보조 명령어입니다. 주로 #함수, !선언, &대상 등과 조합되어 동작의 흐름을 조절하는 데 사용됩니다.

| **코드** | **명칭**   | **의미**      | **설명**                            |
| -------- | ---------- | ------------- | ----------------------------------- |
| ~000     | NOW        | 즉시 실행     | 별도 조건 없이 즉시 실행            |
| ~001     | ASYNC      | 비동기 실행   | 병렬 또는 대기 없이 실행            |
| ~010     | LOOP       | 반복 실행     | 조건 또는 횟수만큼 반복             |
| ~011     | DELAY      | 지연 실행     | 일정 시간 뒤 실행                   |
| ~100     | ON_SUCCESS | 성공 시 실행  | 직전 명령 성공 시 실행              |
| ~101     | ON_FAIL    | 실패 시 실행  | 직전 명령 실패 시 실행              |
| ~110     | ONCE       | 최초 1회 실행 | 동일 조건 반복 호출 방지            |
| ~111     | SCHEDULE   | 예약 실행     | 특정 시점(CRON 등)에 맞춘 실행 예약 |

### # 함수 (#, ~해라)

함수 기호 #는 SonE 프로토콜에서 **동작의 목적**, **실행 방식**, **흐름 제어** 등을 선언할 때 사용합니다. 각 함수는 3비트 코드로 정의되며, 실행 인자(())와 함께 사용됩니다.

| **코드** | **기능 (한글)** | **기능 (영어)** | **역할 정의**                                       |
| -------- | --------------- | --------------- | --------------------------------------------------- |
| #000     | 설정            | SET             | 변수, 상태, 파라미터 등을 설정하거나 초기화         |
| #001     | 조회            | GET             | 현재 상태, 변수, 정보 등을 읽어옴 (조회 전용)       |
| #010     | 실행            | RUN             | 외부 또는 내부 명령을 실행 (함수 호출, 명령 실행)   |
| #011     | 분기            | BRANCH          | 조건에 따라 흐름을 나눔 (if-else 구조, 분기 진입점) |
| #100     | 저장            | SAVE            | 데이터를 영속적 저장소(DB, 파일 등)에 저장          |
| #101     | 전송            | SEND            | 메시지, 명령, 데이터 등을 대상에 전송               |
| #110     | 반복            | LOOP            | 리스트, 배열, 반복 가능한 구조를 순회               |
| #111     | 기록            | LOG             | 실행 내용, 상태, 결과를 기록 또는 출력 (로그 목적)  |

### $ 참조

$ 기호는 코드 외부의 상태, 정의, 경로, 변수 등을 참조하는 모든 대상에 사용됩니다. SonE에서 $는 항상 **읽기 기반의 외부 정보 접근**입니다.

| **코드** | **명칭** | **의미**                              |
| -------- | -------- | ------------------------------------- |
| $000     | REF      | 외부 참조 (기본 참조자)               |
| $001     | VAR      | 사용자 정의 변수                      |
| $010     | CONST    | 상수값 참조                           |
| $011     | ENV      | 시스템 환경 변수                      |
| $100     | FUNC     | 함수 또는 루틴 이름 참조              |
| $101     | PATH     | 외부 경로, URL 등 참조                |
| $110     | MOD      | 외부 모듈 또는 코드 블록 참조         |
| $111     | GEN      | 생성형 외부 요소 (자동 선언, 매핑 등) |

### ! 선언

!는 **선언 또는 초기화** 의미에 어울립니다. 트리거, 이벤트, 스케줄 등의 발생 조건을 담습니다.

| **코드** | **명칭 (한글)** | **명칭 (영어)**        | **설명**                           |
| -------- | --------------- | ---------------------- | ---------------------------------- |
| !000     | 블록 선언       | DECLARE_BLOCK          | 기본 실행 블록 (기본값, {} 포함)   |
| !001     | 상수 선언       | DECLARE_CONST          | 재정의 불가한 상수 정의            |
| !010     | 변수 선언       | DECLARE_VAR            | 수정 가능한 전역/지역 변수         |
| !011     | 계약 선언       | DECLARE_CONTRACT       | 스마트 컨트랙트 구문 시작          |
| !100     | 에이전트 선언   | DECLARE_AGENT          | AI Agent의 역할 또는 유형 정의     |
| !101     | 이벤트 리스너   | DECLARE_EVENT_LISTENER | @상태가 발생할 때 실행될 블록 연결 |
| !110     | 함수 선언       | DECLARE_FUNCTION       | 재사용 가능한 명명된 함수 블록     |
| !111     | 재정의 선언     | FORCE_OVERRIDE         | 기존 선언 강제 덮어쓰기 (!!)       |

### % 데이터 조작

%는 단순 참조($)가 아닌 **데이터 조작 전용 기호**입니다.

| **코드** | **명칭 (한글)** | **명칭 (영어)** | **설명**                     |
| -------- | --------------- | --------------- | ---------------------------- |
| %000     | 추가하기        | PUSH            | 리스트, 큐, 맵에 값 추가     |
| %001     | 꺼내기          | POP             | 마지막 또는 지정된 항목 추출 |
| %010     | 조회하기        | GET_BY_ID       | 특정 식별자로 항목 읽기      |
| %011     | 수정하기        | UPDATE_BY_ID    | 특정 식별자 항목 수정        |
| %100     | 삭제하기        | DELETE_BY_ID    | 특정 식별자 항목 삭제        |
| %101     | 개수 세기       | COUNT           | 항목 총 개수 반환            |
| %110     | 전체 비우기     | CLEAR           | 모든 항목 제거               |
| %111     | 정렬하기        | SORT            | 키 또는 조건 기준 정렬       |

**※ 참고:** 3비트 8개의 매핑에 해당 기능이 없을 때 !선언 후 기호 뒤에 자연어를 사용 가능합니다.

⸻

## 9. 혼합 기호 조합 (Mixed Symbol Operators)

두 개 이상의 기호가 결합하여 **새로운 연산자 역할**을 합니다.

| **기호 조합** | **명칭**          | **의미**       | **사용 예시**               | **비고**   |
| ------------- | ----------------- | -------------- | --------------------------- | ---------- |
| `=>`          | 경로 매핑         | 개념 → 경로    | `로그인 => auth/login.sone` | 선언/설정  |
| `::`          | 네임스페이스 접근 | 외부 속성 접근 | `$user::email`              | 객체 구조  |
| `->`          | 결과 흐름         | 출력 → 입력    | `#로그인()-> #대시보드()`   | 결과 연동  |
| `!!`          | 재정의            | 강제 초기화    | `!!RESET`                   | 오버라이드 |
| `==`          | 동등 비교         | 값이 같음      | `$a == $b`                  | 조건 내부  |
| `!=`          | 부정 비교         | 값이 다름      | `$a != $b`                  | 조건 내부  |
| `>=`          | 이상 비교         | 크거나 같음    | `$a >= $b`                  | 조건 내부  |
| `<=`          | 이하 비교         | 작거나 같음    | `$a <= $b`                  | 조건 내부  |

⸻

## 10. 자동화 시나리오 예시

SonE 이해를 위한 핵심 시나리오 3개를 포함한다.

### 예시 1. 일일 프로젝트 요약 알림

**요구사항**

매일 오전 09:00, 내가 참여 중인 프로젝트의 "어제 활동 요약"을 DM으로 전송.

**SonE 구조 스케치**

```
! schedule.daily "09:00"
? projects.active.yesterday_activity > 0
@ me
: notify.summary "yesterday_projects"
```

**3비트 코드 표현**

```
!~111 schedule.daily "09:00"
?010 projects.active.yesterday_activity > 0
@&010 me
:#101 notify.summary "yesterday_projects"
```

⸻

### 예시 2. 프로젝트 온보딩 자동화

**요구사항**

프로젝트가 생성되면 기본 퀘스트 3개를 자동 생성하고 멤버에게 환영 메시지 전달.

**SonE 구조 스케치**

```
! on projects.created
@ project.members
: quest.create "starter_pack"
~ broadcast "welcome"
```

**3비트 코드 표현**

```
!101 on projects.created
@&010 project.members
:#010 quest.create "starter_pack"
~000 broadcast "welcome"
```

⸻

### 예시 3. SP 발급 → PP 계산 후속 처리

**요구사항**

감사 유형(S1~S3)의 SP가 발급되면 감사 메시지 전송 → 히스토리 기록 → 조건 시 PP 계산 트리거.

**SonE 구조 스케치**

```
! on sp.issued
? sp.type in ["S1","S2","S3"]
@ sp.receiver
: notify "gratitude"
@ sp.project
: record.sp_history
~ trigger "pp_recalculate"
```

**3비트 코드 표현**

```
!101 on sp.issued
?110 sp.type in ["S1","S2","S3"]
@&010 sp.receiver
:#101 notify "gratitude"
@&010 sp.project
:#111 record.sp_history
~000 trigger "pp_recalculate"
```

⸻

### 예시 4. 조건 분기 및 순차 실행

**요구사항**

사용자 역할이 admin이면 관리자 알림과 로그를 기록하고, 그렇지 않으면 일반 화면으로 리디렉션.

**SonE 표현**

```
?000 $user::role == "admin"
: (#101 notify($관리자) + #111 log($접속기록))
/ #010 redirect($일반화면)
```

⸻

### 예시 5. 에러 처리 및 복구

**요구사항**

파일이 없고 오류 상태이면 예외를 발생시키고 로그를 남김.

**SonE 표현**

```
?111 &001 @100
:110 + #111 log($에러코드)
// → 파일이 없고 오류 상태이면 예외를 발생시키고 로그를 남김
```

⸻

## 11. Parser → Executor 실행 구조

SonE를 실제로 실행하기 위한 기술적 구조 요약.

### 11.1 파서(Parser)

- 문장을 토큰 단위로 분해
- 선언/조건/대상/액션/옵션 노드 생성
- AST(Abstract Syntax Tree) 출력
- 문장 간 실행 순서 정렬

### 11.2 Executor

- AST를 순회하며 각 노드의 의미를 해석
- 알맞은 도메인 핸들러 호출
- 데이터의 읽기/쓰기 트랜잭션 관리
- 자동화 로그 기록
- 오류 처리
- 실행이 끝나면 Manifest 업데이트

### 11.3 Manifest 연동

SonE는 직접 UI를 변경하지 않는다. 모든 변경은 Manifest JSON Snapshot으로 기록되며 UI는 Manifest를 기반으로 실시간 반영된다.

Manifest는 다음과 같은 데이터를 포함한다.

- `points` - 포인트 정보 (XP, SP, PP, GP)
- `quests` - 퀘스트 상태
- `projects` - 프로젝트 정보
- `profile` - 사용자 프로필
- `sp/pp` 상태 - 정표/지분 상태
- `notifications` - 알림
- `activity` - 활동 기록

⸻

## 12. SonE 개발 원칙

**1. 한 문장은 하나의 의도만 가진다**

중첩된 복잡한 흐름은 블록 단위로 나누어 표현한다.

**2. 도메인 모듈을 직접 호출하지 않는다**

항상 SonE 액션 → Executor → 도메인 모듈 순서로 진행해야 한다.

**3. 데이터 정합성은 Executor가 책임진다**

**4. SonE는 플랫폼 외부에서 사용할 수 없다**

손잡고 플랫폼 구조와 tightly-coupled된 전용 DSL이다.

⸻

## 13. 주석 및 스페이스 규칙

### 주석 (Comments)

코드의 가독성과 협업을 위해 주석을 사용합니다.

| 기호     | 명칭           | 정의 및 규칙                                                    |
| -------- | -------------- | --------------------------------------------------------------- |
| **`//`** | **한 줄 주석** | `//` 기호부터 해당 라인의 끝까지 모든 내용은 파서가 무시합니다. |

**※ 참고:** SonE는 문법의 간결성과 파싱 효율을 위해 여러 줄 주석(`/* ... */`)은 공식적으로 지원하지 않습니다.

### 스페이스 철학

' '은 **비어있지 않다.** 그것은 아직 선언되지 않은 모든 가능성의 집합이며, 시스템이 그 자리를 인식하는 순간, 그곳은 우주처럼 확장 가능한 **미지의 명령어 공간**입니다.

"스페이스는 나중에 구조적으로 확장될 가능성이 있는 곳에만 허용"

**일반코드에 의미없는 띄어쓰기 금지!**

→ 여지를 남기기 위해 **스페이스는 의미 있는 공백**으로 사용됨
→ 파서가 해석하지 않더라도, 공간을 남기면 미래 확장 가능
→ 예시: `@AI^@비서 : #실행($기본응답)` ⬅ 여기 뒤에 스페이스 남기기 가능

⸻

## 14. 시각화 및 디버깅 도구

SonE는 다음과 같은 디버깅 및 시각화 도구를 포함합니다:

| **기능 명**           | **설명**                      |
| --------------------- | ----------------------------- |
| `@DEBUG_FLOW`         | 명령어 흐름을 순차적으로 추적 |
| `@VISUALIZE_AST`      | 파서가 생성한 AST를 시각화    |
| `@VERIFY_CONFORMANCE` | 문법 준수 여부 검사           |
| `#LOG($내용)`         | 현재 상태 로그 출력           |
| `#TRACE($명령ID)`     | 실행 트레이스 분석            |

**예시:**

```
@000^@001:#TRACE($시나리오1)
```

⸻

## 15. 향후 확장 계획

- 조건식 확장 (정규식, 비교 연산 확대)
- 블록 기반 복합 로직 정식 지원
- 플러그인 핸들러 추가
- SonE → 자연어 해설기(Explain)
- SonE → SonE 최적화 Rewriter
- SonE Replay Debugger 확장

⸻

## 16. 요약 정의문

SonE는 손잡고 플랫폼의 모든 협업 절차를 구조화·명세화·자동화하기 위한 전용 DSL이다.

자연어와 백엔드 실행 사이의 중간 설계도 역할을 수행하며, 복잡한 협업을 한 문장으로 표현한다.

**핵심 특징:**

- **구조화**: 복잡한 협업 로직을 "한 문장 = 한 의도"로 명확히 표현
- **중간 언어**: 자연어 → SonE → AST → Executor → 도메인 모듈
- **자동화**: 프로젝트, 퀘스트, SP, PP, 알림, 리포트의 전 과정 자동화
- **실행 가능**: Parser와 Executor를 통한 실제 동작 보장
- **Manifest 연동**: 모든 변경 사항이 Manifest JSON으로 기록되어 UI에 실시간 반영

---

**문서 버전:** 2.0  
**최종 업데이트:** 2025-12-14  
**작성자:** 손잡고 플랫폼 개발팀

---

## 관련 문서

- [ARCHITECTURE.md](./ARCHITECTURE.md) - 전체 시스템 아키텍처
- [MANIFEST_PROTOCOL.md](./MANIFEST_PROTOCOL.md) - Manifest Protocol (SonE 연동)
- [BACKEND_STRUCTURE.md](./BACKEND_STRUCTURE.md) - 백엔드 구조
- [DEVELOPMENT_STATUS_REPORT_2025-12-14.md](../DEVELOPMENT_STATUS_REPORT_2025-12-14.md) - 최신 구현 현황

**참고**: SonE Protocol의 실제 구현 상태는 현재 확인 중입니다. Executor 및 Parser 구현 현황은 별도 조사가 필요합니다.
